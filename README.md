# Микросервис chat

## Задачи

1. Принимает подключение с фронта по WebSocket.
2. Принимает сообщения от подключенного пользователя по WebSocket.
3. Отправляет сообщения подключенному пользователю по WebSocket.

_Сервис chat имеют свою базу данных_

## Укрупненно

1. Фронт запрашивает подключение по WebSocket на сервере.
	- в запросе содержится токен авторизации.
	- если у пользователя есть сообщения, то сервер высылает их пользователю.
2. Подключенный пользователь оправляет на сервер сообщения о прочтение сообщения.
3. Подключенный пользователь оправляет на сервер сообщения для оператора. 
4. Высылает подключенному клиенту сообщения от оператора.

## База данных

Таблица Messages

| имя столбца     |                                           |
|-----------------|-------------------------------------------|
| id              | INT UNSIGNED, PRIMARY KEY, AUTO_INCREMENT |
| user_name       | VARCHAR(255) NOT NULL                     |
| invader_name    | VARCHAR(255) NOT NULL                     |
| message         | TEXT                                      |
| created         | DATETIME NOT NULL DEFAULT NOW()           |
| is_from_support | BOOL NOT NULL                             |
| is_read         | BOOL NOT NULL                             |
| is_send         | BOOL NOT NULL                             |

## Логика работы

**1. С фронта приходит запрос на соединение.**

1.1. Проверяется наличие в запросе токена авторизации.

1.1.1. Если токена нет или он не соответствует токену загруженному из файла свойств.
- не давать подключение
- завершить обработку запроса

1.1.2. Если токен соответствует загруженному из файла свойств перейти к выполнению следующего пункта.

1.2. Выбрать из таблицы сообщений пользователю.

1.2.1 Сформировать json объект на основе этих записей.

```json
{
	"error": null,
	"result": {
		"messages": [
			{
				"message_id": 1,
				"message_text": "Message from Client",
				"invader_name": "",
				"is_from_support": false,
				"created": 1678794555,
				"is_read": true
			},
			{
				"message_id": 2,
				"message_text": "Message from Operator",
				"invader_name": "Operator1",
				"is_from_support": true,
				"created": 1678794555,
				"is_read": false
			}
		]
	},
	"id": 1
}
```

1.2.2. Отправить json объект клиенту.

**2. Подключенный пользователь оправляет на сервер сообщения о прочтение сообщения:**

```json
{
	"method": "message.read",
	"params": [
		2
	],
	"id": 1
}
```

2.1.1 Если сообщения не было предназначено для отправителя (для пользователя is_from_support == true) 
или аргументы params не соответствуют ожидаемому типу отправить сообщение об ошибке:

```json
{
	"error": {
		"code": 1,
		"message": "Incorrect argument."
	},
	"result": null,
	"id": 1
}
```
2.1.2. Прекратить обработку запроса

2.2.1. Если сообщения было предназначено для отправителя (для пользователя is_from_support == true) 
выставить у полученных id статус is_read = true

2.2.2 Отправить сообщение о положительном выполнении:

```json
{
	"error": null,
	"result": {
		"message": "Ok"
	},
	"id": 2
}
```

**3. Подключенный пользователь оправляет на сервер сообщения для оператора:**

```json
{
	"method": "message.send",
	"params": [
		"message"
	],
	"id": 1
}
```
3.1.1 Если аргументы params не соответствуют ожидаемому типу, отправить сообщение об ошибке:

```json
{
	"error": {
		"code": 1,
		"message": "Incorrect argument."
	},
	"result": null,
	"id": 1
}
```
3.1.2. Прекратить обработку запроса.

3.2.1. Сохранить сообщение в таблицу.

3.2.2. Отправить сообщение о положительном выполнении:

```json
{
	"error": null,
	"result": { 
		"message":
			{
				"message_id": 3,
				"message_text": "Message from Client",
				"invader_name": "",
				"is_from_support": false,
				"created": 1678794555,
				"is_read": false
			}
	},
	"id": 3
}
```

3.3. Перейти к пункту 4.

**4. Высылает подключенному клиенту новые сообщения.**

4.1. Когда в переписке появляется новое сообщение оно высылается пользователю если тот всё еще подключен:

```json
{
	"error": null,
	"result": { 
		"message":
			{
				"message_id": 3,
				"message_text": "Message from Client",
				"invader_name": "",
				"is_from_support": true,
				"created": 1678794555,
				"is_read": false
			}
	},
	"id": 3
}
```

**5. Подключенный оператор оправляет на сервер сообщения для пользователя:**

```json
{
	"method": "message.send",
	"params": [
		"message"
	],
	"id": 1
}
```
5.1.1 Если аргументы params не соответствуют ожидаемому типу, отправить сообщение об ошибке:

```json
{
	"error": {
		"code": 1,
		"message": "Incorrect argument."
	},
	"result": null,
	"id": 1
}
```
5.1.2. Прекратить обработку запроса

5.2.1. Сохранить сообщение в таблицу.

5.2.2. Отправить сообщение о положительном выполнении:

```json
{
	"error": null,
	"result": { 
		"message":
			{
				"message_id": 3,
				"message_text": "Message from Client",
				"invader_name": "",
				"is_from_support": false,
				"created": 1678794555,
				"is_read": false
			}
	},
	"id": 3
}
```
5.3. Перейти к пункту 4.


**6. Подключенный оператор оправляет на сервер сообщения о прочтение сообщения:**

```json
{
	"method": "message.operatorRead",
	"params": [
		2
	],
	"id": 1
}
```

6.1.1 Если сообщения не было предназначено для отправителя (для оператора is_from_support == false) 
или аргументы params не соответствуют ожидаемому типу отправить сообщение об ошибке:

```json
{
	"error": {
		"code": 1,
		"message": "Incorrect argument."
	},
	"result": null,
	"id": 1
}
```
6.1.2. Прекратить обработку запроса

6.2.1. Если сообщения было предназначено для отправителя (для оператора is_from_support == false) 
выставить у полученных id статус is_read = true

6.2.2 Отправить сообщение о положительном выполнении:

```json
{
	"error": null,
	"result": {
		"message": "Ok"
	},
	"id": 2
}
```